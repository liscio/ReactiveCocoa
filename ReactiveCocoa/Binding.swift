import ReactiveSwift
import enum Result.NoError

/// Represents an endpoint that both accepts values to be presented to the user,
/// and supplies values generated by the user. It wraps both a `Signal` and
/// `BindingTarget`, and serves to handle name collisions between the input and
/// output of a given control.
public final class Binding<Value> {
	/// The target that will update the control for incoming values
	fileprivate let target: BindingTarget<Value>

	/// The signal that provides the user-generated changes
	public let signal: Signal<Value, NoError>

	/// The lifetime of the control
	public var lifetime: Lifetime {
		return target.lifetime
	}

	/// Create an input/output binding that supplies user-generated values, and
	/// accepts values to be presented to the user.
	///
	/// - parameters:
	///   - signal: The signal providing user-generated changes
	///   - target: The binding target that causes the control to update
	internal init(signal: Signal<Value, NoError>, target: BindingTarget<Value>) {
		self.signal = signal
		self.target = target
	}
}

extension Binding: BindingTargetProtocol {
	public func consume(_ value: Value) {
		target.consume(value)
	}

	public static func <~ <S: SignalProtocol>(target: Binding, source: S) -> Disposable? where S.Value == Value, S.Error == NoError {
		return target.target <~ source
	}
}

extension Binding: SignalProtocol {
	public func observe(_ observer: Observer<Value, NoError>) -> Disposable? {
		return signal.observe(observer)
	}
}
