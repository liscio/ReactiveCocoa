import ReactiveSwift
import enum Result.NoError

public protocol BindingInputProtocol {}

/// An endpoint that accepts inputs into a user-facing control
public final class BindingInput<Value>: BindingInputProtocol {
	/// The binding target that causes the control to update
	fileprivate let target: BindingTarget<Value>

	/// The lifetime of the target control
	public var lifetime: Lifetime {
		return target.lifetime
	}

	/// Create an input binding that presents values to the user
	///
	/// - parameters:
	///   - target: The binding target that causes the control to update
	internal init(target: BindingTarget<Value>) {
		self.target = target
	}

	public func consume(_ value: Value) {
		target.consume(value)
	}
}

extension BindingInput: BindingTargetProtocol {
	public static func <~ <S: SignalProtocol>(target: BindingInput, source: S) -> Disposable? where S.Value == Value, S.Error == NoError {
		return target.target <~ source
	}
}

public protocol BindingOutputProtocol {}

/// Represents a source of user-generated values from an interactive control
public final class BindingOutput<Value>: BindingOutputProtocol {
	/// The signal that provides the user-generated changes
	public let signal: Signal<Value, NoError>

	/// Create an output binding that supplies user-generated values
	///
	/// - parameters:
	///	  - signal: The signal providing user-generated changes
	internal init(signal: Signal<Value, NoError>) {
		self.signal = signal
	}
}

extension BindingOutput: SignalProtocol {
	public func observe(_ observer: Observer<Value, NoError>) -> Disposable? {
		return signal.observe(observer)
	}
}

/// Represents an endpoint that both accepts values to be presented to the user,
/// and supplies values generated by the user.
public final class Binding<Value>: BindingInputProtocol, BindingOutputProtocol {
	fileprivate let target: BindingTarget<Value>

	/// The signal that provides the user-generated changes
	public let signal: Signal<Value, NoError>

	/// The lifetime of the control
	public var lifetime: Lifetime {
		return target.lifetime
	}

	/// Create an input/output binding that supplies user-generated values, and
	/// accepts values to be presented to the user.
	///
	/// - parameters:
	///   - signal: The signal providing user-generated changes
	///   - target: The binding target that causes the control to update
	internal init(signal: Signal<Value, NoError>, target: BindingTarget<Value>) {
		self.signal = signal
		self.target = target
	}
}

extension Binding: BindingTargetProtocol {
	public func consume(_ value: Value) {
		target.consume(value)
	}

	public static func <~ <S: SignalProtocol>(target: Binding, source: S) -> Disposable? where S.Value == Value, S.Error == NoError {
		return target.target <~ source
	}
}

extension Binding: SignalProtocol {
	public func observe(_ observer: Observer<Value, NoError>) -> Disposable? {
		return signal.observe(observer)
	}
}
